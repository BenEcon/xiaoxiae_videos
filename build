#!/bin/python3

"""A script for building and renaming all of the Manim scenes."""
import subprocess
import shutil
import os
import argparse
import re

from glob import glob


video_directory = "video"

parser = argparse.ArgumentParser()

parser.add_argument(
    "-s", "--scenes",
    nargs='*',
    help="the name of the scenes to build; builds all when omitted",
    default=None,
)

parser.add_argument(
    "-q", "--quality",
    choices=["m", "h", "k"],
    default="k",
    help="the quality of the video (4K by default)"
)

os.chdir(os.path.dirname(os.path.abspath(__file__)))

arguments = parser.parse_args()


def render_scene(scene: str):
    """Render a single scene."""
    quality_mapping = {
        "m": (1280, 720, 30),
        "h": (1920, 1080, 60),
        "k": (3840, 2160, 60),
    }

    w, h, f = quality_mapping[arguments.quality]

    build_dir = os.path.abspath(os.path.dirname(__file__))

    if os.path.isfile(os.path.join(build_dir, ".short")):
        w, h = h, w

    args = ["python3", "-m", "manim", "scenes.py", "--fps", str(f), "-r", f"{w},{h}", "--disable_caching", scene]

    if scene.lower().startswith("transparent"):
        args.append("-t")

    process = subprocess.Popen(args)
    process.communicate()

    if process.returncode != 0:
        print(f"\nBuild failed with exit code {process.returncode}")
        quit()


scenes = []

# please lord forgive me for I have sinned
# this is needed because classes ending with Transparent are going to be rendered transparently
# and classes that contain "Test" are ignored
with open("scenes.py", "r") as f:
    for line in f.read().splitlines():
        if match := re.match(r"\s*class\s+(.+?)\(.*Scene\)\s*:", line):
            scenes.append(match.group(1))

if arguments.scenes is None or len(arguments.scenes) == 0:
    # remove everything when no scene is specified
    if os.path.exists(video_directory):
        shutil.rmtree(video_directory)

    for scene in scenes:
        if "Test" in scene:
            continue

        render_scene(scene)
else:
    for scene in arguments.scenes:
        # remove only the scene and its folders when the scene is specified
        scene_folder = os.path.join(video_directory, scene)
        if os.path.exists(scene_folder):
            shutil.rmtree(scene_folder)

        for ext in ["mp4", "mov"]:
            scene_video = os.path.join(video_directory, scene + f".{ext}")
            if os.path.exists(scene_video):
                os.remove(scene_video)

        render_scene(scene)


# rename to [1..n].whatever
for scene in os.listdir(video_directory):
    if os.path.isdir(os.path.join(video_directory, scene)):
        partial_file_path = os.path.join(video_directory, scene, "partial_movie_file_list.txt")

        if os.path.exists(partial_file_path):
            with open(partial_file_path) as f:
                for i, video in enumerate(f.read().splitlines()[1:]):
                    path, name = os.path.split(video[11:-1])

                    ext = os.path.splitext(name)[1][1:]

                    original_path = os.path.join(path, name)
                    changed_path = os.path.join(path, f"{i+1}.{ext}")

                    os.rename(original_path, changed_path)

            os.remove(partial_file_path)
